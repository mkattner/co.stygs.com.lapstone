// Input 0
/*
 Chart.js
 http://chartjs.org/
 Version: 1.0.2

 Copyright 2015 Nick Downie
 Released under the MIT license
 https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
*/
'use strict';
(function() {
  var l = this, d = l.Chart, c = function(a) {
    this.canvas = a.canvas;
    this.ctx = a;
    var e = function(a, e) {
      return a["offset" + e] ? a["offset" + e] : document.defaultView.getComputedStyle(a).getPropertyValue(e);
    };
    this.width = e(a.canvas, "Width") || a.canvas.width;
    this.height = e(a.canvas, "Height") || a.canvas.height;
    this.width = a.canvas.width;
    this.height = a.canvas.height;
    this.aspectRatio = this.width / this.height;
    b.retinaScale(this);
    return this;
  };
  c.defaults = {global:{animation:!0, animationSteps:60, animationEasing:"easeOutQuart", showScale:!0, scaleOverride:!1, scaleSteps:null, scaleStepWidth:null, scaleStartValue:null, scaleLineColor:"rgba(0,0,0,.1)", scaleLineWidth:1, scaleShowLabels:!0, scaleLabel:"\x3c%\x3dvalue%\x3e", scaleIntegersOnly:!0, scaleBeginAtZero:!1, scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", scaleFontSize:12, scaleFontStyle:"normal", scaleFontColor:"#666", responsive:!1, maintainAspectRatio:!0, 
  showTooltips:!0, customTooltips:!1, tooltipEvents:["mousemove", "touchstart", "touchmove", "mouseout"], tooltipFillColor:"rgba(0,0,0,0.8)", tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", tooltipFontSize:14, tooltipFontStyle:"normal", tooltipFontColor:"#fff", tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", tooltipTitleFontSize:14, tooltipTitleFontStyle:"bold", tooltipTitleFontColor:"#fff", tooltipTitleTemplate:"\x3c%\x3d label%\x3e", tooltipYPadding:6, 
  tooltipXPadding:6, tooltipCaretSize:8, tooltipCornerRadius:6, tooltipXOffset:10, tooltipTemplate:"\x3c%if (label){%\x3e\x3c%\x3dlabel%\x3e: \x3c%}%\x3e\x3c%\x3d value %\x3e", multiTooltipTemplate:"\x3c%\x3d value %\x3e", multiTooltipKeyBackground:"#fff", segmentColorDefault:"#A6CEE3 #1F78B4 #B2DF8A #33A02C #FB9A99 #E31A1C #FDBF6F #FF7F00 #CAB2D6 #6A3D9A #B4B482 #B15928".split(" "), segmentHighlightColorDefaults:"#CEF6FF #47A0DC #DAFFB2 #5BC854 #FFC2C1 #FF4244 #FFE797 #FFA728 #F2DAFE #9265C2 #DCDCAA #D98150".split(" "), 
  onAnimationProgress:function() {
  }, onAnimationComplete:function() {
  }}};
  c.types = {};
  var b = c.helpers = {}, f = b.each = function(a, e, h) {
    var b = Array.prototype.slice.call(arguments, 3);
    if (a) {
      if (a.length === +a.length) {
        var c;
        for (c = 0; c < a.length; c++) {
          e.apply(h, [a[c], c].concat(b));
        }
      } else {
        for (c in a) {
          e.apply(h, [a[c], c].concat(b));
        }
      }
    }
  }, g = b.clone = function(a) {
    var e = {};
    f(a, function(h, b) {
      a.hasOwnProperty(b) && (e[b] = h);
    });
    return e;
  }, k = b.extend = function(a) {
    f(Array.prototype.slice.call(arguments, 1), function(e) {
      f(e, function(h, b) {
        e.hasOwnProperty(b) && (a[b] = h);
      });
    });
    return a;
  }, F = b.merge = function(a, e) {
    var h = Array.prototype.slice.call(arguments, 0);
    h.unshift({});
    return k.apply(null, h);
  }, G = b.indexOf = function(a, e) {
    if (Array.prototype.indexOf) {
      return a.indexOf(e);
    }
    for (var h = 0; h < a.length; h++) {
      if (a[h] === e) {
        return h;
      }
    }
    return -1;
  };
  b.where = function(a, e) {
    var h = [];
    b.each(a, function(a) {
      e(a) && h.push(a);
    });
    return h;
  };
  b.findNextWhere = function(a, e, h) {
    h || (h = -1);
    for (h += 1; h < a.length; h++) {
      var b = a[h];
      if (e(b)) {
        return b;
      }
    }
  };
  b.findPreviousWhere = function(a, e, h) {
    h || (h = a.length);
    for (--h; 0 <= h; h--) {
      var b = a[h];
      if (e(b)) {
        return b;
      }
    }
  };
  var q = b.inherits = function(a) {
    var e = this, h = a && a.hasOwnProperty("constructor") ? a.constructor : function() {
      return e.apply(this, arguments);
    }, b = function() {
      this.constructor = h;
    };
    b.prototype = e.prototype;
    h.prototype = new b;
    h.extend = q;
    a && k(h.prototype, a);
    h.__super__ = e.prototype;
    return h;
  }, m = b.noop = function() {
  }, H = b.uid = function() {
    var a = 0;
    return function() {
      return "chart-" + a++;
    };
  }(), I = b.warn = function(a) {
    window.console && "function" === typeof window.console.warn && console.warn(a);
  }, J = b.amd = "function" === typeof define && define.amd, t = b.isNumber = function(a) {
    return !isNaN(parseFloat(a)) && isFinite(a);
  }, x = b.max = function(a) {
    return Math.max.apply(Math, a);
  }, v = b.min = function(a) {
    return Math.min.apply(Math, a);
  };
  b.cap = function(a, e, h) {
    if (t(e)) {
      if (a > e) {
        return e;
      }
    } else {
      if (t(h) && a < h) {
        return h;
      }
    }
    return a;
  };
  var B = b.getDecimalPlaces = function(a) {
    if (0 !== a % 1 && t(a)) {
      a = a.toString();
      if (0 > a.indexOf("e-")) {
        return a.split(".")[1].length;
      }
      if (0 > a.indexOf(".")) {
        return parseInt(a.split("e-")[1]);
      }
      a = a.split(".")[1].split("e-");
      return a[0].length + parseInt(a[1]);
    }
    return 0;
  }, z = b.radians = function(a) {
    return Math.PI / 180 * a;
  };
  b.getAngleFromPoint = function(a, e) {
    var h = e.x - a.x;
    a = e.y - a.y;
    e = Math.sqrt(h * h + a * a);
    var b = 2 * Math.PI + Math.atan2(a, h);
    0 > h && 0 > a && (b += 2 * Math.PI);
    return {angle:b, distance:e};
  };
  var C = b.aliasPixel = function(a) {
    return 0 === a % 2 ? 0 : 0.5;
  };
  b.splineCurve = function(a, e, h, b) {
    var c = Math.sqrt(Math.pow(e.x - a.x, 2) + Math.pow(e.y - a.y, 2)), f = Math.sqrt(Math.pow(h.x - e.x, 2) + Math.pow(h.y - e.y, 2)), d = b * c / (c + f);
    b = b * f / (c + f);
    return {inner:{x:e.x - d * (h.x - a.x), y:e.y - d * (h.y - a.y)}, outer:{x:e.x + b * (h.x - a.x), y:e.y + b * (h.y - a.y)}};
  };
  var K = b.calculateOrderOfMagnitude = function(a) {
    return Math.floor(Math.log(a) / Math.LN10);
  };
  b.calculateScaleRange = function(a, e, h, b, c) {
    e = Math.floor(e / (1.5 * h));
    h = 2 >= e;
    var d = [];
    f(a, function(a) {
      null == a || d.push(a);
    });
    var g = v(d), p = x(d);
    p === g && (p += 0.5, 0.5 <= g && !b ? g -= 0.5 : p += 0.5);
    a = K(Math.abs(p - g));
    b = b ? 0 : Math.floor(g / (1 * Math.pow(10, a))) * Math.pow(10, a);
    p = Math.ceil(p / (1 * Math.pow(10, a))) * Math.pow(10, a) - b;
    g = Math.pow(10, a);
    for (var n = Math.round(p / g); (n > e || 2 * n < e) && !h;) {
      if (n > e) {
        g *= 2, n = Math.round(p / g), 0 !== n % 1 && (h = !0);
      } else {
        if (c && 0 <= a) {
          if (0 === g / 2 % 1) {
            g /= 2, n = Math.round(p / g);
          } else {
            break;
          }
        } else {
          g /= 2, n = Math.round(p / g);
        }
      }
    }
    h && (n = 2, g = p / n);
    return {steps:n, stepValue:g, min:b, max:b + n * g};
  };
  var r = b.template = function(a, e) {
    if (a instanceof Function) {
      return a(e);
    }
    var b = {};
    a = /\W/.test(a) ? new Function("obj", "var p\x3d[],print\x3dfunction(){p.push.apply(p,arguments);};with(obj){p.push('" + a.replace(/[\r\t\n]/g, " ").split("\x3c%").join("\t").replace(/((^|%>)[^\t]*)'/g, "$1\r").replace(/\t=(.*?)%>/g, "',$1,'").split("\t").join("');").split("%\x3e").join("p.push('").split("\r").join("\\'") + "');}return p.join('');") : b[a] = b[a];
    return e ? a(e) : a;
  };
  b.generateLabels = function(a, e, b, c) {
    var h = Array(e);
    a && f(h, function(e, f) {
      h[f] = r(a, {value:b + c * (f + 1)});
    });
    return h;
  };
  var w = b.easingEffects = {linear:function(a) {
    return a;
  }, easeInQuad:function(a) {
    return a * a;
  }, easeOutQuad:function(a) {
    return -1 * a * (a - 2);
  }, easeInOutQuad:function(a) {
    return 1 > (a /= .5) ? .5 * a * a : -.5 * (--a * (a - 2) - 1);
  }, easeInCubic:function(a) {
    return a * a * a;
  }, easeOutCubic:function(a) {
    return (a = a / 1 - 1) * a * a + 1;
  }, easeInOutCubic:function(a) {
    return 1 > (a /= .5) ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2);
  }, easeInQuart:function(a) {
    return a * a * a * a;
  }, easeOutQuart:function(a) {
    return -1 * ((a = a / 1 - 1) * a * a * a - 1);
  }, easeInOutQuart:function(a) {
    return 1 > (a /= .5) ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2);
  }, easeInQuint:function(a) {
    return (a /= 1) * a * a * a * a;
  }, easeOutQuint:function(a) {
    return (a = a / 1 - 1) * a * a * a * a + 1;
  }, easeInOutQuint:function(a) {
    return 1 > (a /= .5) ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2);
  }, easeInSine:function(a) {
    return -1 * Math.cos(a / 1 * (Math.PI / 2)) + 1;
  }, easeOutSine:function(a) {
    return 1 * Math.sin(a / 1 * (Math.PI / 2));
  }, easeInOutSine:function(a) {
    return -.5 * (Math.cos(Math.PI * a) - 1);
  }, easeInExpo:function(a) {
    return 0 === a ? 1 : 1 * Math.pow(2, 10 * (a / 1 - 1));
  }, easeOutExpo:function(a) {
    return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1;
  }, easeInOutExpo:function(a) {
    return 0 === a ? 0 : 1 === a ? 1 : 1 > (a /= .5) ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (-Math.pow(2, -10 * --a) + 2);
  }, easeInCirc:function(a) {
    return 1 <= a ? a : -1 * (Math.sqrt(1 - (a /= 1) * a) - 1);
  }, easeOutCirc:function(a) {
    return 1 * Math.sqrt(1 - (a = a / 1 - 1) * a);
  }, easeInOutCirc:function(a) {
    return 1 > (a /= .5) ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
  }, easeInElastic:function(a) {
    var e = 0, b = 1;
    if (0 === a) {
      return 0;
    }
    if (1 == (a /= 1)) {
      return 1;
    }
    e || (e = .3);
    if (1 > b) {
      b = 1;
      var c = e / 4;
    } else {
      c = e / (2 * Math.PI) * Math.asin(1 / b);
    }
    return -(b * Math.pow(2, 10 * --a) * Math.sin(2 * (1 * a - c) * Math.PI / e));
  }, easeOutElastic:function(a) {
    var e = 0, b = 1;
    if (0 === a) {
      return 0;
    }
    if (1 == (a /= 1)) {
      return 1;
    }
    e || (e = .3);
    if (1 > b) {
      b = 1;
      var c = e / 4;
    } else {
      c = e / (2 * Math.PI) * Math.asin(1 / b);
    }
    return b * Math.pow(2, -10 * a) * Math.sin(2 * (1 * a - c) * Math.PI / e) + 1;
  }, easeInOutElastic:function(a) {
    var e = 0, b = 1;
    if (0 === a) {
      return 0;
    }
    if (2 == (a /= .5)) {
      return 1;
    }
    e || (e = 0.3 * 1.5);
    if (1 > b) {
      b = 1;
      var c = e / 4;
    } else {
      c = e / (2 * Math.PI) * Math.asin(1 / b);
    }
    return 1 > a ? -0.5 * b * Math.pow(2, 10 * --a) * Math.sin(2 * (1 * a - c) * Math.PI / e) : b * Math.pow(2, -10 * --a) * Math.sin(2 * (1 * a - c) * Math.PI / e) * 0.5 + 1;
  }, easeInBack:function(a) {
    return (a /= 1) * a * (2.70158 * a - 1.70158);
  }, easeOutBack:function(a) {
    return (a = a / 1 - 1) * a * (2.70158 * a + 1.70158) + 1;
  }, easeInOutBack:function(a) {
    var e = 1.70158;
    return 1 > (a /= .5) ? .5 * a * a * (((e *= 1.525) + 1) * a - e) : .5 * ((a -= 2) * a * (((e *= 1.525) + 1) * a + e) + 2);
  }, easeInBounce:function(a) {
    return 1 - w.easeOutBounce(1 - a);
  }, easeOutBounce:function(a) {
    return (a /= 1) < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
  }, easeInOutBounce:function(a) {
    return .5 > a ? 0.5 * w.easeInBounce(2 * a) : 0.5 * w.easeOutBounce(2 * a - 1) + .5;
  }}, D = b.requestAnimFrame = function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
      return window.setTimeout(a, 1000 / 60);
    };
  }();
  b.cancelAnimFrame = function() {
    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(a) {
      return window.clearTimeout(a, 1000 / 60);
    };
  }();
  b.animationLoop = function(a, e, b, c, f, g) {
    var h = 0, d = w[b] || w.linear, p = function() {
      h++;
      var b = h / e, n = d(b);
      a.call(g, n, b, h);
      c.call(g, n, b);
      h < e ? g.animationFrame = D(p) : f.apply(g);
    };
    D(p);
  };
  b.getRelativePosition = function(a) {
    var e = a.originalEvent || a;
    var b = (a.currentTarget || a.srcElement).getBoundingClientRect();
    e.touches ? (a = e.touches[0].clientX - b.left, e = e.touches[0].clientY - b.top) : (a = e.clientX - b.left, e = e.clientY - b.top);
    return {x:a, y:e};
  };
  var L = b.addEvent = function(a, e, b) {
    a.addEventListener ? a.addEventListener(e, b) : a.attachEvent ? a.attachEvent("on" + e, b) : a["on" + e] = b;
  }, M = b.removeEvent = function(a, e, b) {
    a.removeEventListener ? a.removeEventListener(e, b, !1) : a.detachEvent ? a.detachEvent("on" + e, b) : a["on" + e] = m;
  };
  b.bindEvents = function(a, e, b) {
    a.events || (a.events = {});
    f(e, function(e) {
      a.events[e] = function() {
        b.apply(a, arguments);
      };
      L(a.chart.canvas, e, a.events[e]);
    });
  };
  var N = b.unbindEvents = function(a, e) {
    f(e, function(e, b) {
      M(a.chart.canvas, b, e);
    });
  }, O = b.getMaximumWidth = function(a) {
    a = a.parentNode;
    var e = parseInt(y(a, "padding-left")) + parseInt(y(a, "padding-right"));
    return a.clientWidth - e;
  }, P = b.getMaximumHeight = function(a) {
    a = a.parentNode;
    var e = parseInt(y(a, "padding-bottom")) + parseInt(y(a, "padding-top"));
    return a.clientHeight - e;
  }, y = b.getStyle = function(a, e) {
    return a.currentStyle ? a.currentStyle[e] : document.defaultView.getComputedStyle(a, null).getPropertyValue(e);
  };
  b.getMaximumSize = b.getMaximumWidth;
  var Q = b.retinaScale = function(a) {
    var e = a.ctx, b = a.canvas.width;
    a = a.canvas.height;
    window.devicePixelRatio && (e.canvas.style.width = b + "px", e.canvas.style.height = a + "px", e.canvas.height = a * window.devicePixelRatio, e.canvas.width = b * window.devicePixelRatio, e.scale(window.devicePixelRatio, window.devicePixelRatio));
  }, R = b.clear = function(a) {
    a.ctx.clearRect(0, 0, a.width, a.height);
  }, u = b.fontString = function(a, e, b) {
    return e + " " + a + "px " + b;
  }, A = b.longestText = function(a, e, b) {
    a.font = e;
    var c = 0;
    f(b, function(e) {
      e = a.measureText(e).width;
      c = e > c ? e : c;
    });
    return c;
  }, E = b.drawRoundedRectangle = function(a, e, b, c, f, g) {
    a.beginPath();
    a.moveTo(e + g, b);
    a.lineTo(e + c - g, b);
    a.quadraticCurveTo(e + c, b, e + c, b + g);
    a.lineTo(e + c, b + f - g);
    a.quadraticCurveTo(e + c, b + f, e + c - g, b + f);
    a.lineTo(e + g, b + f);
    a.quadraticCurveTo(e, b + f, e, b + f - g);
    a.lineTo(e, b + g);
    a.quadraticCurveTo(e, b, e + g, b);
    a.closePath();
  };
  c.instances = {};
  c.Type = function(a, b, f) {
    this.options = b;
    this.chart = f;
    this.id = H();
    c.instances[this.id] = this;
    b.responsive && this.resize();
    this.initialize.call(this, a);
  };
  k(c.Type.prototype, {initialize:function() {
    return this;
  }, clear:function() {
    R(this.chart);
    return this;
  }, stop:function() {
    c.animationService.cancelAnimation(this);
    return this;
  }, resize:function(a) {
    this.stop();
    var b = this.chart.canvas, c = O(this.chart.canvas), f = this.options.maintainAspectRatio ? c / this.chart.aspectRatio : P(this.chart.canvas);
    b.width = this.chart.width = c;
    b.height = this.chart.height = f;
    Q(this.chart);
    "function" === typeof a && a.apply(this, Array.prototype.slice.call(arguments, 1));
    return this;
  }, reflow:m, render:function(a) {
    a && this.reflow();
    this.options.animation && !a ? (a = new c.Animation, a.numSteps = this.options.animationSteps, a.easing = this.options.animationEasing, a.render = function(a, c) {
      var e = c.currentStep / c.numSteps, f = (0,b.easingEffects[c.easing])(e);
      a.draw(f, e, c.currentStep);
    }, a.onAnimationProgress = this.options.onAnimationProgress, a.onAnimationComplete = this.options.onAnimationComplete, c.animationService.addAnimation(this, a)) : (this.draw(), this.options.onAnimationComplete.call(this));
    return this;
  }, generateLegend:function() {
    return r(this.options.legendTemplate, this);
  }, destroy:function() {
    this.clear();
    N(this, this.events);
    var a = this.chart.canvas;
    a.width = this.chart.width;
    a.height = this.chart.height;
    a.style.removeProperty ? (a.style.removeProperty("width"), a.style.removeProperty("height")) : (a.style.removeAttribute("width"), a.style.removeAttribute("height"));
    delete c.instances[this.id];
  }, showTooltip:function(a, e) {
    "undefined" === typeof this.activeElements && (this.activeElements = []);
    if (function(a) {
      var b = !1;
      if (a.length !== this.activeElements.length) {
        return b = !0;
      }
      f(a, function(a, e) {
        a !== this.activeElements[e] && (b = !0);
      }, this);
      return b;
    }.call(this, a) || e) {
      this.activeElements = a;
      this.draw();
      this.options.customTooltips && this.options.customTooltips(!1);
      if (0 < a.length) {
        if (this.datasets && 1 < this.datasets.length) {
          for (var h, g = this.datasets.length - 1; 0 <= g && (e = this.datasets[g].points || this.datasets[g].bars || this.datasets[g].segments, h = G(e, a[0]), -1 === h); g--) {
          }
          var d = [], k = [];
          e = function(a) {
            var e = [], c, f = [], g = [];
            b.each(this.datasets, function(a) {
              c = a.points || a.bars || a.segments;
              c[h] && c[h].hasValue() && e.push(c[h]);
            });
            b.each(e, function(a) {
              f.push(a.x);
              g.push(a.y);
              d.push(b.template(this.options.multiTooltipTemplate, a));
              k.push({fill:a._saved.fillColor || a.fillColor, stroke:a._saved.strokeColor || a.strokeColor});
            }, this);
            var p = v(g);
            var n = x(g);
            var m = v(f);
            a = x(f);
            return {x:m > this.chart.width / 2 ? m : a, y:(p + n) / 2};
          }.call(this, h);
          (new c.MultiTooltip({x:e.x, y:e.y, xPadding:this.options.tooltipXPadding, yPadding:this.options.tooltipYPadding, xOffset:this.options.tooltipXOffset, fillColor:this.options.tooltipFillColor, textColor:this.options.tooltipFontColor, fontFamily:this.options.tooltipFontFamily, fontStyle:this.options.tooltipFontStyle, fontSize:this.options.tooltipFontSize, titleTextColor:this.options.tooltipTitleFontColor, titleFontFamily:this.options.tooltipTitleFontFamily, titleFontStyle:this.options.tooltipTitleFontStyle, 
          titleFontSize:this.options.tooltipTitleFontSize, cornerRadius:this.options.tooltipCornerRadius, labels:d, legendColors:k, legendColorBackground:this.options.multiTooltipKeyBackground, title:r(this.options.tooltipTitleTemplate, a[0]), chart:this.chart, ctx:this.chart.ctx, custom:this.options.customTooltips})).draw();
        } else {
          f(a, function(a) {
            var b = a.tooltipPosition();
            (new c.Tooltip({x:Math.round(b.x), y:Math.round(b.y), xPadding:this.options.tooltipXPadding, yPadding:this.options.tooltipYPadding, fillColor:this.options.tooltipFillColor, textColor:this.options.tooltipFontColor, fontFamily:this.options.tooltipFontFamily, fontStyle:this.options.tooltipFontStyle, fontSize:this.options.tooltipFontSize, caretHeight:this.options.tooltipCaretSize, cornerRadius:this.options.tooltipCornerRadius, text:r(this.options.tooltipTemplate, a), chart:this.chart, custom:this.options.customTooltips})).draw();
          }, this);
        }
      }
      return this;
    }
  }, toBase64Image:function() {
    return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
  }});
  c.Type.extend = function(a) {
    var b = this, f = function() {
      return b.apply(this, arguments);
    };
    f.prototype = g(b.prototype);
    k(f.prototype, a);
    f.extend = c.Type.extend;
    if (a.name || b.prototype.name) {
      var d = a.name || b.prototype.name, n = c.defaults[b.prototype.name] ? g(c.defaults[b.prototype.name]) : {};
      c.defaults[d] = k(n, a.defaults);
      c.types[d] = f;
      c.prototype[d] = function(a, b) {
        b = F(c.defaults.global, c.defaults[d], b || {});
        return new f(a, b, this);
      };
    } else {
      I("Name not provided for this chart, so it hasn't been registered");
    }
    return b;
  };
  c.Element = function(a) {
    k(this, a);
    this.initialize.apply(this, arguments);
    this.save();
  };
  k(c.Element.prototype, {initialize:function() {
  }, restore:function(a) {
    a ? f(a, function(a) {
      this[a] = this._saved[a];
    }, this) : k(this, this._saved);
    return this;
  }, save:function() {
    this._saved = g(this);
    delete this._saved._saved;
    return this;
  }, update:function(a) {
    f(a, function(a, b) {
      this._saved[b] = this[b];
      this[b] = a;
    }, this);
    return this;
  }, transition:function(a, b) {
    f(a, function(a, e) {
      this[e] = (a - this._saved[e]) * b + this._saved[e];
    }, this);
    return this;
  }, tooltipPosition:function() {
    return {x:this.x, y:this.y};
  }, hasValue:function() {
    return t(this.value);
  }});
  c.Element.extend = q;
  c.Point = c.Element.extend({display:!0, inRange:function(a, b) {
    return Math.pow(a - this.x, 2) + Math.pow(b - this.y, 2) < Math.pow(this.hitDetectionRadius + this.radius, 2);
  }, draw:function() {
    if (this.display) {
      var a = this.ctx;
      a.beginPath();
      a.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
      a.closePath();
      a.strokeStyle = this.strokeColor;
      a.lineWidth = this.strokeWidth;
      a.fillStyle = this.fillColor;
      a.fill();
      a.stroke();
    }
  }});
  c.Arc = c.Element.extend({inRange:function(a, e) {
    var c = b.getAngleFromPoint(this, {x:a, y:e});
    a = c.angle % (2 * Math.PI);
    e = (2 * Math.PI + this.startAngle) % (2 * Math.PI);
    var f = (2 * Math.PI + this.endAngle) % (2 * Math.PI) || 360;
    c = c.distance >= this.innerRadius && c.distance <= this.outerRadius;
    return (f < e ? a <= f || a >= e : a >= e && a <= f) && c;
  }, tooltipPosition:function() {
    var a = this.startAngle + (this.endAngle - this.startAngle) / 2, b = (this.outerRadius - this.innerRadius) / 2 + this.innerRadius;
    return {x:this.x + Math.cos(a) * b, y:this.y + Math.sin(a) * b};
  }, draw:function(a) {
    a = this.ctx;
    a.beginPath();
    a.arc(this.x, this.y, 0 > this.outerRadius ? 0 : this.outerRadius, this.startAngle, this.endAngle);
    a.arc(this.x, this.y, 0 > this.innerRadius ? 0 : this.innerRadius, this.endAngle, this.startAngle, !0);
    a.closePath();
    a.strokeStyle = this.strokeColor;
    a.lineWidth = this.strokeWidth;
    a.fillStyle = this.fillColor;
    a.fill();
    a.lineJoin = "bevel";
    this.showStroke && a.stroke();
  }});
  c.Rectangle = c.Element.extend({draw:function() {
    var a = this.ctx, b = this.width / 2, c = this.x - b;
    b = this.x + b;
    var f = this.base - (this.base - this.y), g = this.strokeWidth / 2;
    this.showStroke && (c += g, b -= g, f += g);
    a.beginPath();
    a.fillStyle = this.fillColor;
    a.strokeStyle = this.strokeColor;
    a.lineWidth = this.strokeWidth;
    a.moveTo(c, this.base);
    a.lineTo(c, f);
    a.lineTo(b, f);
    a.lineTo(b, this.base);
    a.fill();
    this.showStroke && a.stroke();
  }, height:function() {
    return this.base - this.y;
  }, inRange:function(a, b) {
    return a >= this.x - this.width / 2 && a <= this.x + this.width / 2 && b >= this.y && b <= this.base;
  }});
  c.Animation = c.Element.extend({currentStep:null, numSteps:60, easing:"", render:null, onAnimationProgress:null, onAnimationComplete:null});
  c.Tooltip = c.Element.extend({draw:function() {
    var a = this.chart.ctx;
    a.font = u(this.fontSize, this.fontStyle, this.fontFamily);
    this.xAlign = "center";
    this.yAlign = "above";
    var b = this.caretPadding = 2, c = a.measureText(this.text).width + 2 * this.xPadding, f = this.fontSize + 2 * this.yPadding, g = f + this.caretHeight + b;
    this.x + c / 2 > this.chart.width ? this.xAlign = "left" : 0 > this.x - c / 2 && (this.xAlign = "right");
    0 > this.y - g && (this.yAlign = "below");
    var d = this.x - c / 2;
    g = this.y - g;
    a.fillStyle = this.fillColor;
    if (this.custom) {
      this.custom(this);
    } else {
      switch(this.yAlign) {
        case "above":
          a.beginPath();
          a.moveTo(this.x, this.y - b);
          a.lineTo(this.x + this.caretHeight, this.y - (b + this.caretHeight));
          a.lineTo(this.x - this.caretHeight, this.y - (b + this.caretHeight));
          a.closePath();
          a.fill();
          break;
        case "below":
          g = this.y + b + this.caretHeight, a.beginPath(), a.moveTo(this.x, this.y + b), a.lineTo(this.x + this.caretHeight, this.y + b + this.caretHeight), a.lineTo(this.x - this.caretHeight, this.y + b + this.caretHeight), a.closePath(), a.fill();
      }
      switch(this.xAlign) {
        case "left":
          d = this.x - c + (this.cornerRadius + this.caretHeight);
          break;
        case "right":
          d = this.x - (this.cornerRadius + this.caretHeight);
      }
      E(a, d, g, c, f, this.cornerRadius);
      a.fill();
      a.fillStyle = this.textColor;
      a.textAlign = "center";
      a.textBaseline = "middle";
      a.fillText(this.text, d + c / 2, g + f / 2);
    }
  }});
  c.MultiTooltip = c.Element.extend({initialize:function() {
    this.font = u(this.fontSize, this.fontStyle, this.fontFamily);
    this.titleFont = u(this.titleFontSize, this.titleFontStyle, this.titleFontFamily);
    this.titleHeight = this.title ? 1.5 * this.titleFontSize : 0;
    this.height = this.labels.length * this.fontSize + this.fontSize / 2 * (this.labels.length - 1) + 2 * this.yPadding + this.titleHeight;
    this.ctx.font = this.titleFont;
    var a = this.ctx.measureText(this.title).width, b = A(this.ctx, this.font, this.labels) + this.fontSize + 3;
    this.width = x([b, a]) + 2 * this.xPadding;
    a = this.height / 2;
    0 > this.y - a ? this.y = a : this.y + a > this.chart.height && (this.y = this.chart.height - a);
    this.x = this.x > this.chart.width / 2 ? this.x - (this.xOffset + this.width) : this.x + this.xOffset;
  }, getLineHeight:function(a) {
    var b = this.y - this.height / 2 + this.yPadding;
    return 0 === a ? b + this.titleHeight / 3 : b + (1.5 * this.fontSize * (a - 1) + this.fontSize / 2) + this.titleHeight;
  }, draw:function() {
    if (this.custom) {
      this.custom(this);
    } else {
      E(this.ctx, this.x, this.y - this.height / 2, this.width, this.height, this.cornerRadius);
      var a = this.ctx;
      a.fillStyle = this.fillColor;
      a.fill();
      a.closePath();
      a.textAlign = "left";
      a.textBaseline = "middle";
      a.fillStyle = this.titleTextColor;
      a.font = this.titleFont;
      a.fillText(this.title, this.x + this.xPadding, this.getLineHeight(0));
      a.font = this.font;
      b.each(this.labels, function(b, c) {
        a.fillStyle = this.textColor;
        a.fillText(b, this.x + this.xPadding + this.fontSize + 3, this.getLineHeight(c + 1));
        a.fillStyle = this.legendColorBackground;
        a.fillRect(this.x + this.xPadding, this.getLineHeight(c + 1) - this.fontSize / 2, this.fontSize, this.fontSize);
        a.fillStyle = this.legendColors[c].fill;
        a.fillRect(this.x + this.xPadding, this.getLineHeight(c + 1) - this.fontSize / 2, this.fontSize, this.fontSize);
      }, this);
    }
  }});
  c.Scale = c.Element.extend({initialize:function() {
    this.fit();
  }, buildYLabels:function() {
    this.yLabels = [];
    for (var a = B(this.stepValue), b = 0; b <= this.steps; b++) {
      this.yLabels.push(r(this.templateString, {value:(this.min + b * this.stepValue).toFixed(a)}));
    }
    this.yLabelWidth = this.display && this.showLabels ? A(this.ctx, this.font, this.yLabels) + 10 : 0;
  }, addXLabel:function(a) {
    this.xLabels.push(a);
    this.valuesCount++;
    this.fit();
  }, removeXLabel:function() {
    this.xLabels.shift();
    this.valuesCount--;
    this.fit();
  }, fit:function() {
    this.startPoint = this.display ? this.fontSize : 0;
    this.endPoint = this.display ? this.height - 1.5 * this.fontSize - 5 : this.height;
    this.startPoint += this.padding;
    var a = this.endPoint -= this.padding, b = this.endPoint - this.startPoint;
    this.calculateYRange(b);
    this.buildYLabels();
    for (this.calculateXLabelRotation(); b > this.endPoint - this.startPoint;) {
      b = this.endPoint - this.startPoint;
      var c = this.yLabelWidth;
      this.calculateYRange(b);
      this.buildYLabels();
      c < this.yLabelWidth && (this.endPoint = a, this.calculateXLabelRotation());
    }
  }, calculateXLabelRotation:function() {
    this.ctx.font = this.font;
    var a = this.ctx.measureText(this.xLabels[0]).width;
    this.xScalePaddingRight = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width / 2 + 3;
    this.xScalePaddingLeft = a / 2 > this.yLabelWidth ? a / 2 : this.yLabelWidth;
    this.xLabelRotation = 0;
    if (this.display) {
      var b = A(this.ctx, this.font, this.xLabels);
      this.xLabelWidth = b;
      for (var c = Math.floor(this.calculateX(1) - this.calculateX(0)) - 6; this.xLabelWidth > c && 0 === this.xLabelRotation || this.xLabelWidth > c && 90 >= this.xLabelRotation && 0 < this.xLabelRotation;) {
        var f = Math.cos(z(this.xLabelRotation));
        var g = f * a;
        g + this.fontSize / 2 > this.yLabelWidth && (this.xScalePaddingLeft = g + this.fontSize / 2);
        this.xScalePaddingRight = this.fontSize / 2;
        this.xLabelRotation++;
        this.xLabelWidth = f * b;
      }
      0 < this.xLabelRotation && (this.endPoint -= Math.sin(z(this.xLabelRotation)) * b + 3);
    } else {
      this.xLabelWidth = 0, this.xScalePaddingLeft = this.xScalePaddingRight = this.padding;
    }
  }, calculateYRange:m, drawingArea:function() {
    return this.startPoint - this.endPoint;
  }, calculateY:function(a) {
    var b = this.drawingArea() / (this.min - this.max);
    return this.endPoint - b * (a - this.min);
  }, calculateX:function(a) {
    var b = (this.width - (this.xScalePaddingLeft + this.xScalePaddingRight)) / Math.max(this.valuesCount - (this.offsetGridLines ? 0 : 1), 1);
    a = b * a + this.xScalePaddingLeft;
    this.offsetGridLines && (a += b / 2);
    return Math.round(a);
  }, update:function(a) {
    b.extend(this, a);
    this.fit();
  }, draw:function() {
    var a = this.ctx, c = (this.endPoint - this.startPoint) / this.steps, g = Math.round(this.xScalePaddingLeft);
    this.display && (a.fillStyle = this.textColor, a.font = this.font, f(this.yLabels, function(e, f) {
      var d = this.endPoint - c * f, h = Math.round(d), k = this.showHorizontalLines;
      a.textAlign = "right";
      a.textBaseline = "middle";
      this.showLabels && a.fillText(e, g - 10, d);
      0 !== f || k || (k = !0);
      k && a.beginPath();
      0 < f ? (a.lineWidth = this.gridLineWidth, a.strokeStyle = this.gridLineColor) : (a.lineWidth = this.lineWidth, a.strokeStyle = this.lineColor);
      h += b.aliasPixel(a.lineWidth);
      k && (a.moveTo(g, h), a.lineTo(this.width, h), a.stroke(), a.closePath());
      a.lineWidth = this.lineWidth;
      a.strokeStyle = this.lineColor;
      a.beginPath();
      a.moveTo(g - 5, h);
      a.lineTo(g, h);
      a.stroke();
      a.closePath();
    }, this), f(this.xLabels, function(b, c) {
      var e = this.calculateX(c) + C(this.lineWidth), f = this.calculateX(c - (this.offsetGridLines ? 0.5 : 0)) + C(this.lineWidth), g = 0 < this.xLabelRotation, d = this.showVerticalLines;
      0 !== c || d || (d = !0);
      d && a.beginPath();
      0 < c ? (a.lineWidth = this.gridLineWidth, a.strokeStyle = this.gridLineColor) : (a.lineWidth = this.lineWidth, a.strokeStyle = this.lineColor);
      d && (a.moveTo(f, this.endPoint), a.lineTo(f, this.startPoint - 3), a.stroke(), a.closePath());
      a.lineWidth = this.lineWidth;
      a.strokeStyle = this.lineColor;
      a.beginPath();
      a.moveTo(f, this.endPoint);
      a.lineTo(f, this.endPoint + 5);
      a.stroke();
      a.closePath();
      a.save();
      a.translate(e, g ? this.endPoint + 12 : this.endPoint + 8);
      a.rotate(-1 * z(this.xLabelRotation));
      a.font = this.font;
      a.textAlign = g ? "right" : "center";
      a.textBaseline = g ? "middle" : "top";
      a.fillText(b, 0, 0);
      a.restore();
    }, this));
  }});
  c.RadialScale = c.Element.extend({initialize:function() {
    this.size = v([this.height, this.width]);
    this.drawingArea = this.display ? this.size / 2 - (this.fontSize / 2 + this.backdropPaddingY) : this.size / 2;
  }, calculateCenterOffset:function(a) {
    return this.drawingArea / (this.max - this.min) * (a - this.min);
  }, update:function() {
    this.lineArc ? this.drawingArea = this.display ? this.size / 2 - (this.fontSize / 2 + this.backdropPaddingY) : this.size / 2 : this.setScaleSize();
    this.buildYLabels();
  }, buildYLabels:function() {
    this.yLabels = [];
    for (var a = B(this.stepValue), b = 0; b <= this.steps; b++) {
      this.yLabels.push(r(this.templateString, {value:(this.min + b * this.stepValue).toFixed(a)}));
    }
  }, getCircumference:function() {
    return 2 * Math.PI / this.valuesCount;
  }, setScaleSize:function() {
    var a = v([this.height / 2 - this.pointLabelFontSize - 5, this.width / 2]), b, c = this.width, f = 0;
    this.ctx.font = u(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily);
    for (b = 0; b < this.valuesCount; b++) {
      var g = this.getPointPosition(b, a);
      var d = this.ctx.measureText(r(this.templateString, {value:this.labels[b]})).width + 5;
      if (0 === b || b === this.valuesCount / 2) {
        d /= 2;
        if (g.x + d > c) {
          c = g.x + d;
          var k = b;
        }
        if (g.x - d < f) {
          f = g.x - d;
          var m = b;
        }
      } else {
        b < this.valuesCount / 2 ? g.x + d > c && (c = g.x + d, k = b) : b > this.valuesCount / 2 && g.x - d < f && (f = g.x - d, m = b);
      }
    }
    g = f;
    c = Math.ceil(c - this.width);
    k = this.getIndexAngle(k);
    m = this.getIndexAngle(m);
    k = c / Math.sin(k + Math.PI / 2);
    m = g / Math.sin(m + Math.PI / 2);
    k = t(k) ? k : 0;
    m = t(m) ? m : 0;
    this.drawingArea = a - (m + k) / 2;
    this.setCenterPoint(m, k);
  }, setCenterPoint:function(a, b) {
    this.xCenter = (a + this.drawingArea + (this.width - b - this.drawingArea)) / 2;
    this.yCenter = this.height / 2;
  }, getIndexAngle:function(a) {
    return 2 * Math.PI / this.valuesCount * a - Math.PI / 2;
  }, getPointPosition:function(a, b) {
    a = this.getIndexAngle(a);
    return {x:Math.cos(a) * b + this.xCenter, y:Math.sin(a) * b + this.yCenter};
  }, draw:function() {
    if (this.display) {
      var a = this.ctx;
      f(this.yLabels, function(b, c) {
        if (0 < c) {
          var f = this.drawingArea / this.steps * c, g = this.yCenter - f;
          if (0 < this.lineWidth) {
            a.strokeStyle = this.lineColor;
            a.lineWidth = this.lineWidth;
            if (this.lineArc) {
              a.beginPath(), a.arc(this.xCenter, this.yCenter, f, 0, 2 * Math.PI);
            } else {
              a.beginPath();
              for (var e = 0; e < this.valuesCount; e++) {
                f = this.getPointPosition(e, this.calculateCenterOffset(this.min + c * this.stepValue)), 0 === e ? a.moveTo(f.x, f.y) : a.lineTo(f.x, f.y);
              }
            }
            a.closePath();
            a.stroke();
          }
          this.showLabels && (a.font = u(this.fontSize, this.fontStyle, this.fontFamily), this.showLabelBackdrop && (c = a.measureText(b).width, a.fillStyle = this.backdropColor, a.fillRect(this.xCenter - c / 2 - this.backdropPaddingX, g - this.fontSize / 2 - this.backdropPaddingY, c + 2 * this.backdropPaddingX, this.fontSize + 2 * this.backdropPaddingY)), a.textAlign = "center", a.textBaseline = "middle", a.fillStyle = this.fontColor, a.fillText(b, this.xCenter, g));
        }
      }, this);
      if (!this.lineArc) {
        a.lineWidth = this.angleLineWidth;
        a.strokeStyle = this.angleLineColor;
        for (var b = this.valuesCount - 1; 0 <= b; b--) {
          var c = null, g = null;
          0 < this.angleLineWidth && (c = this.calculateCenterOffset(this.max), g = this.getPointPosition(b, c), a.beginPath(), a.moveTo(this.xCenter, this.yCenter), a.lineTo(g.x, g.y), a.stroke(), a.closePath());
          if (this.backgroundColors && this.backgroundColors.length == this.valuesCount) {
            null == c && (c = this.calculateCenterOffset(this.max));
            null == g && (g = this.getPointPosition(b, c));
            var d = this.getPointPosition(0 === b ? this.valuesCount - 1 : b - 1, c), k = this.getPointPosition(b === this.valuesCount - 1 ? 0 : b + 1, c);
            c = (d.x + g.x) / 2;
            d = (d.y + g.y) / 2;
            var m = (g.x + k.x) / 2;
            k = (g.y + k.y) / 2;
            a.beginPath();
            a.moveTo(this.xCenter, this.yCenter);
            a.lineTo(c, d);
            a.lineTo(g.x, g.y);
            a.lineTo(m, k);
            a.fillStyle = this.backgroundColors[b];
            a.fill();
            a.closePath();
          }
          g = this.getPointPosition(b, this.calculateCenterOffset(this.max) + 5);
          a.font = u(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily);
          a.fillStyle = this.pointLabelFontColor;
          d = this.labels.length;
          c = this.labels.length / 2;
          m = c / 2;
          k = b < m || b > d - m;
          d = b === m || b === d - m;
          a.textAlign = 0 === b ? "center" : b === c ? "center" : b < c ? "left" : "right";
          a.textBaseline = d ? "middle" : k ? "bottom" : "top";
          a.fillText(this.labels[b], g.x, g.y);
        }
      }
    }
  }});
  c.animationService = {frameDuration:17, animations:[], dropFrames:0, addAnimation:function(a, c) {
    for (var f = 0; f < this.animations.length; ++f) {
      if (this.animations[f].chartInstance === a) {
        this.animations[f].animationObject = c;
        return;
      }
    }
    this.animations.push({chartInstance:a, animationObject:c});
    1 == this.animations.length && b.requestAnimFrame.call(window, this.digestWrapper);
  }, cancelAnimation:function(a) {
    var c = b.findNextWhere(this.animations, function(b) {
      return b.chartInstance === a;
    });
    c && this.animations.splice(c, 1);
  }, digestWrapper:function() {
    c.animationService.startDigest.call(c.animationService);
  }, startDigest:function() {
    var a = Date.now(), c = 0;
    1 < this.dropFrames && (c = Math.floor(this.dropFrames), this.dropFrames -= c);
    for (var f = 0; f < this.animations.length; f++) {
      null === this.animations[f].animationObject.currentStep && (this.animations[f].animationObject.currentStep = 0), this.animations[f].animationObject.currentStep += 1 + c, this.animations[f].animationObject.currentStep > this.animations[f].animationObject.numSteps && (this.animations[f].animationObject.currentStep = this.animations[f].animationObject.numSteps), this.animations[f].animationObject.render(this.animations[f].chartInstance, this.animations[f].animationObject), this.animations[f].animationObject.currentStep == 
      this.animations[f].animationObject.numSteps && (this.animations[f].animationObject.onAnimationComplete.call(this.animations[f].chartInstance), this.animations.splice(f, 1), f--);
    }
    a = (Date.now() - a - this.frameDuration) / this.frameDuration;
    1 < a && (this.dropFrames += a);
    0 < this.animations.length && b.requestAnimFrame.call(window, this.digestWrapper);
  }};
  b.addEvent(window, "resize", function() {
    var a;
    return function() {
      clearTimeout(a);
      a = setTimeout(function() {
        f(c.instances, function(a) {
          a.options.responsive && a.resize(a.render, !0);
        });
      }, 50);
    };
  }());
  J ? define(function() {
    return c;
  }) : "object" === typeof module && module.exports && (module.exports = c);
  l.Chart = c;
  c.noConflict = function() {
    l.Chart = d;
    return c;
  };
}).call(this);
(function() {
  var l = this.Chart, d = l.helpers;
  l.Type.extend({name:"Bar", defaults:{scaleBeginAtZero:!0, scaleShowGridLines:!0, scaleGridLineColor:"rgba(0,0,0,.05)", scaleGridLineWidth:1, scaleShowHorizontalLines:!0, scaleShowVerticalLines:!0, barShowStroke:!0, barStrokeWidth:2, barValueSpacing:5, barDatasetSpacing:1, legendTemplate:'\x3cul class\x3d"\x3c%\x3dname.toLowerCase()%\x3e-legend"\x3e\x3c% for (var i\x3d0; i\x3cdatasets.length; i++){%\x3e\x3cli\x3e\x3cspan style\x3d"background-color:\x3c%\x3ddatasets[i].fillColor%\x3e"\x3e\x3c%if(datasets[i].label){%\x3e\x3c%\x3ddatasets[i].label%\x3e\x3c%}%\x3e\x3c/span\x3e\x3c/li\x3e\x3c%}%\x3e\x3c/ul\x3e'}, 
  initialize:function(c) {
    var b = this.options;
    this.ScaleClass = l.Scale.extend({offsetGridLines:!0, calculateBarX:function(c, g, d) {
      var f = this.calculateBaseWidth();
      d = this.calculateX(d) - f / 2;
      c = this.calculateBarWidth(c);
      return d + c * g + g * b.barDatasetSpacing + c / 2;
    }, calculateBaseWidth:function() {
      return this.calculateX(1) - this.calculateX(0) - 2 * b.barValueSpacing;
    }, calculateBarWidth:function(c) {
      return (this.calculateBaseWidth() - (c - 1) * b.barDatasetSpacing) / c;
    }});
    this.datasets = [];
    this.options.showTooltips && d.bindEvents(this, this.options.tooltipEvents, function(b) {
      b = "mouseout" !== b.type ? this.getBarsAtEvent(b) : [];
      this.eachBars(function(b) {
        b.restore(["fillColor", "strokeColor"]);
      });
      d.each(b, function(b) {
        b.fillColor = b.highlightFill;
        b.strokeColor = b.highlightStroke;
      });
      this.showTooltip(b);
    });
    this.BarClass = l.Rectangle.extend({strokeWidth:this.options.barStrokeWidth, showStroke:this.options.barShowStroke, ctx:this.chart.ctx});
    d.each(c.datasets, function(b, g) {
      var f = {label:b.label || null, fillColor:b.fillColor, strokeColor:b.strokeColor, bars:[]};
      this.datasets.push(f);
      d.each(b.data, function(g, d) {
        f.bars.push(new this.BarClass({value:g, label:c.labels[d], datasetLabel:b.label, strokeColor:b.strokeColor, fillColor:b.fillColor, highlightFill:b.highlightFill || b.fillColor, highlightStroke:b.highlightStroke || b.strokeColor}));
      }, this);
    }, this);
    this.buildScale(c.labels);
    this.BarClass.prototype.base = this.scale.endPoint;
    this.eachBars(function(b, c, k) {
      d.extend(b, {width:this.scale.calculateBarWidth(this.datasets.length), x:this.scale.calculateBarX(this.datasets.length, k, c), y:this.scale.endPoint});
      b.save();
    }, this);
    this.render();
  }, update:function() {
    this.scale.update();
    d.each(this.activeElements, function(c) {
      c.restore(["fillColor", "strokeColor"]);
    });
    this.eachBars(function(c) {
      c.save();
    });
    this.render();
  }, eachBars:function(c) {
    d.each(this.datasets, function(b, f) {
      d.each(b.bars, c, this, f);
    }, this);
  }, getBarsAtEvent:function(c) {
    var b = [];
    c = d.getRelativePosition(c);
    for (var f = function(c) {
      b.push(c.bars[g]);
    }, g, k = 0; k < this.datasets.length; k++) {
      for (g = 0; g < this.datasets[k].bars.length; g++) {
        if (this.datasets[k].bars[g].inRange(c.x, c.y)) {
          return d.each(this.datasets, f), b;
        }
      }
    }
    return b;
  }, buildScale:function(c) {
    var b = this, f = function() {
      var c = [];
      b.eachBars(function(b) {
        c.push(b.value);
      });
      return c;
    };
    c = {templateString:this.options.scaleLabel, height:this.chart.height, width:this.chart.width, ctx:this.chart.ctx, textColor:this.options.scaleFontColor, fontSize:this.options.scaleFontSize, fontStyle:this.options.scaleFontStyle, fontFamily:this.options.scaleFontFamily, valuesCount:c.length, beginAtZero:this.options.scaleBeginAtZero, integersOnly:this.options.scaleIntegersOnly, calculateYRange:function(b) {
      b = d.calculateScaleRange(f(), b, this.fontSize, this.beginAtZero, this.integersOnly);
      d.extend(this, b);
    }, xLabels:c, font:d.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily), lineWidth:this.options.scaleLineWidth, lineColor:this.options.scaleLineColor, showHorizontalLines:this.options.scaleShowHorizontalLines, showVerticalLines:this.options.scaleShowVerticalLines, gridLineWidth:this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0, gridLineColor:this.options.scaleShowGridLines ? this.options.scaleGridLineColor : "rgba(0,0,0,0)", padding:this.options.showScale ? 
    0 : this.options.barShowStroke ? this.options.barStrokeWidth : 0, showLabels:this.options.scaleShowLabels, display:this.options.showScale};
    this.options.scaleOverride && d.extend(c, {calculateYRange:d.noop, steps:this.options.scaleSteps, stepValue:this.options.scaleStepWidth, min:this.options.scaleStartValue, max:this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth});
    this.scale = new this.ScaleClass(c);
  }, addData:function(c, b) {
    d.each(c, function(c, g) {
      this.datasets[g].bars.push(new this.BarClass({value:c, label:b, datasetLabel:this.datasets[g].label, x:this.scale.calculateBarX(this.datasets.length, g, this.scale.valuesCount + 1), y:this.scale.endPoint, width:this.scale.calculateBarWidth(this.datasets.length), base:this.scale.endPoint, strokeColor:this.datasets[g].strokeColor, fillColor:this.datasets[g].fillColor}));
    }, this);
    this.scale.addXLabel(b);
    this.update();
  }, removeData:function() {
    this.scale.removeXLabel();
    d.each(this.datasets, function(c) {
      c.bars.shift();
    }, this);
    this.update();
  }, reflow:function() {
    d.extend(this.BarClass.prototype, {y:this.scale.endPoint, base:this.scale.endPoint});
    var c = d.extend({height:this.chart.height, width:this.chart.width});
    this.scale.update(c);
  }, draw:function(c) {
    var b = c || 1;
    this.clear();
    this.scale.draw(b);
    d.each(this.datasets, function(c, g) {
      d.each(c.bars, function(c, f) {
        c.hasValue() && (c.base = this.scale.endPoint, c.transition({x:this.scale.calculateBarX(this.datasets.length, g, f), y:this.scale.calculateY(c.value), width:this.scale.calculateBarWidth(this.datasets.length)}, b).draw());
      }, this);
    }, this);
  }});
}).call(this);
(function() {
  var l = this.Chart, d = l.helpers, c = {segmentShowStroke:!0, segmentStrokeColor:"#fff", segmentStrokeWidth:2, percentageInnerCutout:50, animationSteps:100, animationEasing:"easeOutBounce", animateRotate:!0, animateScale:!1, legendTemplate:'\x3cul class\x3d"\x3c%\x3dname.toLowerCase()%\x3e-legend"\x3e\x3c% for (var i\x3d0; i\x3csegments.length; i++){%\x3e\x3cli\x3e\x3cspan style\x3d"background-color:\x3c%\x3dsegments[i].fillColor%\x3e"\x3e\x3c%if(segments[i].label){%\x3e\x3c%\x3dsegments[i].label%\x3e\x3c%}%\x3e\x3c/span\x3e\x3c/li\x3e\x3c%}%\x3e\x3c/ul\x3e'};
  l.Type.extend({name:"Doughnut", defaults:c, initialize:function(b) {
    this.segments = [];
    this.outerRadius = (d.min([this.chart.width, this.chart.height]) - this.options.segmentStrokeWidth / 2) / 2;
    this.SegmentArc = l.Arc.extend({ctx:this.chart.ctx, x:this.chart.width / 2, y:this.chart.height / 2});
    this.options.showTooltips && d.bindEvents(this, this.options.tooltipEvents, function(b) {
      b = "mouseout" !== b.type ? this.getSegmentsAtEvent(b) : [];
      d.each(this.segments, function(b) {
        b.restore(["fillColor"]);
      });
      d.each(b, function(b) {
        b.fillColor = b.highlightColor;
      });
      this.showTooltip(b);
    });
    this.calculateTotal(b);
    d.each(b, function(c, g) {
      c.color || (c.color = "hsl(" + 360 * g / b.length + ", 100%, 50%)");
      this.addData(c, g, !0);
    }, this);
    this.render();
  }, getSegmentsAtEvent:function(b) {
    var c = [], g = d.getRelativePosition(b);
    d.each(this.segments, function(b) {
      b.inRange(g.x, g.y) && c.push(b);
    }, this);
    return c;
  }, addData:function(b, c, g) {
    c = void 0 !== c ? c : this.segments.length;
    "undefined" === typeof b.color && (b.color = l.defaults.global.segmentColorDefault[c % l.defaults.global.segmentColorDefault.length], b.highlight = l.defaults.global.segmentHighlightColorDefaults[c % l.defaults.global.segmentHighlightColorDefaults.length]);
    this.segments.splice(c, 0, new this.SegmentArc({value:b.value, outerRadius:this.options.animateScale ? 0 : this.outerRadius, innerRadius:this.options.animateScale ? 0 : this.outerRadius / 100 * this.options.percentageInnerCutout, fillColor:b.color, highlightColor:b.highlight || b.color, showStroke:this.options.segmentShowStroke, strokeWidth:this.options.segmentStrokeWidth, strokeColor:this.options.segmentStrokeColor, startAngle:1.5 * Math.PI, circumference:this.options.animateRotate ? 0 : this.calculateCircumference(b.value), 
    label:b.label}));
    g || (this.reflow(), this.update());
  }, calculateCircumference:function(b) {
    return 0 < this.total ? b / this.total * Math.PI * 2 : 0;
  }, calculateTotal:function(b) {
    this.total = 0;
    d.each(b, function(b) {
      this.total += Math.abs(b.value);
    }, this);
  }, update:function() {
    this.calculateTotal(this.segments);
    d.each(this.activeElements, function(b) {
      b.restore(["fillColor"]);
    });
    d.each(this.segments, function(b) {
      b.save();
    });
    this.render();
  }, removeData:function(b) {
    b = d.isNumber(b) ? b : this.segments.length - 1;
    this.segments.splice(b, 1);
    this.reflow();
    this.update();
  }, reflow:function() {
    d.extend(this.SegmentArc.prototype, {x:this.chart.width / 2, y:this.chart.height / 2});
    this.outerRadius = (d.min([this.chart.width, this.chart.height]) - this.options.segmentStrokeWidth / 2) / 2;
    d.each(this.segments, function(b) {
      b.update({outerRadius:this.outerRadius, innerRadius:this.outerRadius / 100 * this.options.percentageInnerCutout});
    }, this);
  }, draw:function(b) {
    var c = b ? b : 1;
    this.clear();
    d.each(this.segments, function(b, f) {
      b.transition({circumference:this.calculateCircumference(b.value), outerRadius:this.outerRadius, innerRadius:this.outerRadius / 100 * this.options.percentageInnerCutout}, c);
      b.endAngle = b.startAngle + b.circumference;
      b.draw();
      0 === f && (b.startAngle = 1.5 * Math.PI);
      f < this.segments.length - 1 && (this.segments[f + 1].startAngle = b.endAngle);
    }, this);
  }});
  l.types.Doughnut.extend({name:"Pie", defaults:d.merge(c, {percentageInnerCutout:0})});
}).call(this);
(function() {
  var l = this.Chart, d = l.helpers;
  l.Type.extend({name:"Line", defaults:{scaleShowGridLines:!0, scaleGridLineColor:"rgba(0,0,0,.05)", scaleGridLineWidth:1, scaleShowHorizontalLines:!0, scaleShowVerticalLines:!0, bezierCurve:!0, bezierCurveTension:0.4, pointDot:!0, pointDotRadius:4, pointDotStrokeWidth:1, pointHitDetectionRadius:20, datasetStroke:!0, datasetStrokeWidth:2, datasetFill:!0, legendTemplate:'\x3cul class\x3d"\x3c%\x3dname.toLowerCase()%\x3e-legend"\x3e\x3c% for (var i\x3d0; i\x3cdatasets.length; i++){%\x3e\x3cli\x3e\x3cspan style\x3d"background-color:\x3c%\x3ddatasets[i].strokeColor%\x3e"\x3e\x3c%if(datasets[i].label){%\x3e\x3c%\x3ddatasets[i].label%\x3e\x3c%}%\x3e\x3c/span\x3e\x3c/li\x3e\x3c%}%\x3e\x3c/ul\x3e', 
  offsetGridLines:!1}, initialize:function(c) {
    this.PointClass = l.Point.extend({offsetGridLines:this.options.offsetGridLines, strokeWidth:this.options.pointDotStrokeWidth, radius:this.options.pointDotRadius, display:this.options.pointDot, hitDetectionRadius:this.options.pointHitDetectionRadius, ctx:this.chart.ctx, inRange:function(b) {
      return Math.pow(b - this.x, 2) < Math.pow(this.radius + this.hitDetectionRadius, 2);
    }});
    this.datasets = [];
    this.options.showTooltips && d.bindEvents(this, this.options.tooltipEvents, function(b) {
      b = "mouseout" !== b.type ? this.getPointsAtEvent(b) : [];
      this.eachPoints(function(b) {
        b.restore(["fillColor", "strokeColor"]);
      });
      d.each(b, function(b) {
        b.fillColor = b.highlightFill;
        b.strokeColor = b.highlightStroke;
      });
      this.showTooltip(b);
    });
    d.each(c.datasets, function(b) {
      var f = {label:b.label || null, fillColor:b.fillColor, strokeColor:b.strokeColor, pointColor:b.pointColor, pointStrokeColor:b.pointStrokeColor, points:[]};
      this.datasets.push(f);
      d.each(b.data, function(g, d) {
        f.points.push(new this.PointClass({value:g, label:c.labels[d], datasetLabel:b.label, strokeColor:b.pointStrokeColor, fillColor:b.pointColor, highlightFill:b.pointHighlightFill || b.pointColor, highlightStroke:b.pointHighlightStroke || b.pointStrokeColor}));
      }, this);
      this.buildScale(c.labels);
      this.eachPoints(function(b, c) {
        d.extend(b, {x:this.scale.calculateX(c), y:this.scale.endPoint});
        b.save();
      }, this);
    }, this);
    this.render();
  }, update:function() {
    this.scale.update();
    d.each(this.activeElements, function(c) {
      c.restore(["fillColor", "strokeColor"]);
    });
    this.eachPoints(function(c) {
      c.save();
    });
    this.render();
  }, eachPoints:function(c) {
    d.each(this.datasets, function(b) {
      d.each(b.points, c, this);
    }, this);
  }, getPointsAtEvent:function(c) {
    var b = [], f = d.getRelativePosition(c);
    d.each(this.datasets, function(c) {
      d.each(c.points, function(c) {
        c.inRange(f.x, f.y) && b.push(c);
      });
    }, this);
    return b;
  }, buildScale:function(c) {
    var b = this, f = function() {
      var c = [];
      b.eachPoints(function(b) {
        c.push(b.value);
      });
      return c;
    };
    c = {templateString:this.options.scaleLabel, height:this.chart.height, width:this.chart.width, ctx:this.chart.ctx, textColor:this.options.scaleFontColor, offsetGridLines:this.options.offsetGridLines, fontSize:this.options.scaleFontSize, fontStyle:this.options.scaleFontStyle, fontFamily:this.options.scaleFontFamily, valuesCount:c.length, beginAtZero:this.options.scaleBeginAtZero, integersOnly:this.options.scaleIntegersOnly, calculateYRange:function(b) {
      b = d.calculateScaleRange(f(), b, this.fontSize, this.beginAtZero, this.integersOnly);
      d.extend(this, b);
    }, xLabels:c, font:d.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily), lineWidth:this.options.scaleLineWidth, lineColor:this.options.scaleLineColor, showHorizontalLines:this.options.scaleShowHorizontalLines, showVerticalLines:this.options.scaleShowVerticalLines, gridLineWidth:this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0, gridLineColor:this.options.scaleShowGridLines ? this.options.scaleGridLineColor : "rgba(0,0,0,0)", padding:this.options.showScale ? 
    0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth, showLabels:this.options.scaleShowLabels, display:this.options.showScale};
    this.options.scaleOverride && d.extend(c, {calculateYRange:d.noop, steps:this.options.scaleSteps, stepValue:this.options.scaleStepWidth, min:this.options.scaleStartValue, max:this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth});
    this.scale = new l.Scale(c);
  }, addData:function(c, b) {
    d.each(c, function(c, d) {
      this.datasets[d].points.push(new this.PointClass({value:c, label:b, datasetLabel:this.datasets[d].label, x:this.scale.calculateX(this.scale.valuesCount + 1), y:this.scale.endPoint, strokeColor:this.datasets[d].pointStrokeColor, fillColor:this.datasets[d].pointColor}));
    }, this);
    this.scale.addXLabel(b);
    this.update();
  }, removeData:function() {
    this.scale.removeXLabel();
    d.each(this.datasets, function(c) {
      c.points.shift();
    }, this);
    this.update();
  }, reflow:function() {
    var c = d.extend({height:this.chart.height, width:this.chart.width});
    this.scale.update(c);
  }, draw:function(c) {
    var b = c || 1;
    this.clear();
    var f = this.chart.ctx, g = function(b) {
      return null !== b.value;
    }, k = function(b, c, f) {
      return d.findNextWhere(c, g, f) || b;
    }, l = function(b, c, f) {
      return d.findPreviousWhere(c, g, f) || b;
    };
    this.scale && (this.scale.draw(b), d.each(this.datasets, function(c) {
      var q = d.where(c.points, g);
      d.each(c.points, function(c, f) {
        c.hasValue() && c.transition({y:this.scale.calculateY(c.value), x:this.scale.calculateX(f)}, b);
      }, this);
      this.options.bezierCurve && d.each(q, function(b, c) {
        var f = 0 < c && c < q.length - 1 ? this.options.bezierCurveTension : 0;
        b.controlPoints = d.splineCurve(l(b, q, c), b, k(b, q, c), f);
        b.controlPoints.outer.y > this.scale.endPoint ? b.controlPoints.outer.y = this.scale.endPoint : b.controlPoints.outer.y < this.scale.startPoint && (b.controlPoints.outer.y = this.scale.startPoint);
        b.controlPoints.inner.y > this.scale.endPoint ? b.controlPoints.inner.y = this.scale.endPoint : b.controlPoints.inner.y < this.scale.startPoint && (b.controlPoints.inner.y = this.scale.startPoint);
      }, this);
      f.lineWidth = this.options.datasetStrokeWidth;
      f.strokeStyle = c.strokeColor;
      f.beginPath();
      d.each(q, function(b, c) {
        0 === c ? f.moveTo(b.x, b.y) : this.options.bezierCurve ? (c = l(b, q, c), f.bezierCurveTo(c.controlPoints.outer.x, c.controlPoints.outer.y, b.controlPoints.inner.x, b.controlPoints.inner.y, b.x, b.y)) : f.lineTo(b.x, b.y);
      }, this);
      this.options.datasetStroke && f.stroke();
      this.options.datasetFill && 0 < q.length && (f.lineTo(q[q.length - 1].x, this.scale.endPoint), f.lineTo(q[0].x, this.scale.endPoint), f.fillStyle = c.fillColor, f.closePath(), f.fill());
      d.each(q, function(b) {
        b.draw();
      });
    }, this));
  }});
}).call(this);
(function() {
  var l = this.Chart, d = l.helpers;
  l.Type.extend({name:"PolarArea", defaults:{scaleShowLabelBackdrop:!0, scaleBackdropColor:"rgba(255,255,255,0.75)", scaleBeginAtZero:!0, scaleBackdropPaddingY:2, scaleBackdropPaddingX:2, scaleShowLine:!0, segmentShowStroke:!0, segmentStrokeColor:"#fff", segmentStrokeWidth:2, animationSteps:100, animationEasing:"easeOutBounce", animateRotate:!0, animateScale:!1, legendTemplate:'\x3cul class\x3d"\x3c%\x3dname.toLowerCase()%\x3e-legend"\x3e\x3c% for (var i\x3d0; i\x3csegments.length; i++){%\x3e\x3cli\x3e\x3cspan style\x3d"background-color:\x3c%\x3dsegments[i].fillColor%\x3e"\x3e\x3c%if(segments[i].label){%\x3e\x3c%\x3dsegments[i].label%\x3e\x3c%}%\x3e\x3c/span\x3e\x3c/li\x3e\x3c%}%\x3e\x3c/ul\x3e'}, 
  initialize:function(c) {
    this.segments = [];
    this.SegmentArc = l.Arc.extend({showStroke:this.options.segmentShowStroke, strokeWidth:this.options.segmentStrokeWidth, strokeColor:this.options.segmentStrokeColor, ctx:this.chart.ctx, innerRadius:0, x:this.chart.width / 2, y:this.chart.height / 2});
    this.scale = new l.RadialScale({display:this.options.showScale, fontStyle:this.options.scaleFontStyle, fontSize:this.options.scaleFontSize, fontFamily:this.options.scaleFontFamily, fontColor:this.options.scaleFontColor, showLabels:this.options.scaleShowLabels, showLabelBackdrop:this.options.scaleShowLabelBackdrop, backdropColor:this.options.scaleBackdropColor, backdropPaddingY:this.options.scaleBackdropPaddingY, backdropPaddingX:this.options.scaleBackdropPaddingX, lineWidth:this.options.scaleShowLine ? 
    this.options.scaleLineWidth : 0, lineColor:this.options.scaleLineColor, lineArc:!0, width:this.chart.width, height:this.chart.height, xCenter:this.chart.width / 2, yCenter:this.chart.height / 2, ctx:this.chart.ctx, templateString:this.options.scaleLabel, valuesCount:c.length});
    this.updateScaleRange(c);
    this.scale.update();
    d.each(c, function(b, c) {
      this.addData(b, c, !0);
    }, this);
    this.options.showTooltips && d.bindEvents(this, this.options.tooltipEvents, function(b) {
      b = "mouseout" !== b.type ? this.getSegmentsAtEvent(b) : [];
      d.each(this.segments, function(b) {
        b.restore(["fillColor"]);
      });
      d.each(b, function(b) {
        b.fillColor = b.highlightColor;
      });
      this.showTooltip(b);
    });
    this.render();
  }, getSegmentsAtEvent:function(c) {
    var b = [], f = d.getRelativePosition(c);
    d.each(this.segments, function(c) {
      c.inRange(f.x, f.y) && b.push(c);
    }, this);
    return b;
  }, addData:function(c, b, f) {
    this.segments.splice(b || this.segments.length, 0, new this.SegmentArc({fillColor:c.color, highlightColor:c.highlight || c.color, label:c.label, value:c.value, outerRadius:this.options.animateScale ? 0 : this.scale.calculateCenterOffset(c.value), circumference:this.options.animateRotate ? 0 : this.scale.getCircumference(), startAngle:1.5 * Math.PI}));
    f || (this.reflow(), this.update());
  }, removeData:function(c) {
    c = d.isNumber(c) ? c : this.segments.length - 1;
    this.segments.splice(c, 1);
    this.reflow();
    this.update();
  }, calculateTotal:function(c) {
    this.total = 0;
    d.each(c, function(b) {
      this.total += b.value;
    }, this);
    this.scale.valuesCount = this.segments.length;
  }, updateScaleRange:function(c) {
    var b = [];
    d.each(c, function(c) {
      b.push(c.value);
    });
    c = this.options.scaleOverride ? {steps:this.options.scaleSteps, stepValue:this.options.scaleStepWidth, min:this.options.scaleStartValue, max:this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth} : d.calculateScaleRange(b, d.min([this.chart.width, this.chart.height]) / 2, this.options.scaleFontSize, this.options.scaleBeginAtZero, this.options.scaleIntegersOnly);
    d.extend(this.scale, c, {size:d.min([this.chart.width, this.chart.height]), xCenter:this.chart.width / 2, yCenter:this.chart.height / 2});
  }, update:function() {
    this.calculateTotal(this.segments);
    d.each(this.segments, function(c) {
      c.save();
    });
    this.reflow();
    this.render();
  }, reflow:function() {
    d.extend(this.SegmentArc.prototype, {x:this.chart.width / 2, y:this.chart.height / 2});
    this.updateScaleRange(this.segments);
    this.scale.update();
    d.extend(this.scale, {xCenter:this.chart.width / 2, yCenter:this.chart.height / 2});
    d.each(this.segments, function(c) {
      c.update({outerRadius:this.scale.calculateCenterOffset(c.value)});
    }, this);
  }, draw:function(c) {
    var b = c || 1;
    this.clear();
    d.each(this.segments, function(c, d) {
      c.transition({circumference:this.scale.getCircumference(), outerRadius:this.scale.calculateCenterOffset(c.value)}, b);
      c.endAngle = c.startAngle + c.circumference;
      0 === d && (c.startAngle = 1.5 * Math.PI);
      d < this.segments.length - 1 && (this.segments[d + 1].startAngle = c.endAngle);
      c.draw();
    }, this);
    this.scale.draw();
  }});
}).call(this);
(function() {
  var l = this.Chart, d = l.helpers;
  l.Type.extend({name:"Radar", defaults:{scaleShowLine:!0, angleShowLineOut:!0, scaleShowLabels:!1, scaleBeginAtZero:!0, angleLineColor:"rgba(0,0,0,.1)", angleLineWidth:1, pointLabelFontFamily:"'Arial'", pointLabelFontStyle:"normal", pointLabelFontSize:10, pointLabelFontColor:"#666", pointDot:!0, pointDotRadius:3, pointDotStrokeWidth:1, pointHitDetectionRadius:20, datasetStroke:!0, datasetStrokeWidth:2, datasetFill:!0, legendTemplate:'\x3cul class\x3d"\x3c%\x3dname.toLowerCase()%\x3e-legend"\x3e\x3c% for (var i\x3d0; i\x3cdatasets.length; i++){%\x3e\x3cli\x3e\x3cspan style\x3d"background-color:\x3c%\x3ddatasets[i].strokeColor%\x3e"\x3e\x3c%if(datasets[i].label){%\x3e\x3c%\x3ddatasets[i].label%\x3e\x3c%}%\x3e\x3c/span\x3e\x3c/li\x3e\x3c%}%\x3e\x3c/ul\x3e'}, 
  initialize:function(c) {
    this.PointClass = l.Point.extend({strokeWidth:this.options.pointDotStrokeWidth, radius:this.options.pointDotRadius, display:this.options.pointDot, hitDetectionRadius:this.options.pointHitDetectionRadius, ctx:this.chart.ctx});
    this.datasets = [];
    this.buildScale(c);
    this.options.showTooltips && d.bindEvents(this, this.options.tooltipEvents, function(b) {
      b = "mouseout" !== b.type ? this.getPointsAtEvent(b) : [];
      this.eachPoints(function(b) {
        b.restore(["fillColor", "strokeColor"]);
      });
      d.each(b, function(b) {
        b.fillColor = b.highlightFill;
        b.strokeColor = b.highlightStroke;
      });
      this.showTooltip(b);
    });
    d.each(c.datasets, function(b) {
      var f = {label:b.label || null, fillColor:b.fillColor, strokeColor:b.strokeColor, pointColor:b.pointColor, pointStrokeColor:b.pointStrokeColor, points:[]};
      this.datasets.push(f);
      d.each(b.data, function(d, k) {
        var g;
        this.scale.animation || (g = this.scale.getPointPosition(k, this.scale.calculateCenterOffset(d)));
        f.points.push(new this.PointClass({value:d, label:c.labels[k], datasetLabel:b.label, x:this.options.animation ? this.scale.xCenter : g.x, y:this.options.animation ? this.scale.yCenter : g.y, strokeColor:b.pointStrokeColor, fillColor:b.pointColor, highlightFill:b.pointHighlightFill || b.pointColor, highlightStroke:b.pointHighlightStroke || b.pointStrokeColor}));
      }, this);
    }, this);
    this.render();
  }, eachPoints:function(c) {
    d.each(this.datasets, function(b) {
      d.each(b.points, c, this);
    }, this);
  }, getPointsAtEvent:function(c) {
    c = d.getRelativePosition(c);
    c = d.getAngleFromPoint({x:this.scale.xCenter, y:this.scale.yCenter}, c);
    var b = Math.round((c.angle - 1.5 * Math.PI) / (2 * Math.PI / this.scale.valuesCount)), f = [];
    if (b >= this.scale.valuesCount || 0 > b) {
      b = 0;
    }
    c.distance <= this.scale.drawingArea && d.each(this.datasets, function(c) {
      f.push(c.points[b]);
    });
    return f;
  }, buildScale:function(c) {
    this.scale = new l.RadialScale({display:this.options.showScale, fontStyle:this.options.scaleFontStyle, fontSize:this.options.scaleFontSize, fontFamily:this.options.scaleFontFamily, fontColor:this.options.scaleFontColor, showLabels:this.options.scaleShowLabels, showLabelBackdrop:this.options.scaleShowLabelBackdrop, backdropColor:this.options.scaleBackdropColor, backgroundColors:this.options.scaleBackgroundColors, backdropPaddingY:this.options.scaleBackdropPaddingY, backdropPaddingX:this.options.scaleBackdropPaddingX, 
    lineWidth:this.options.scaleShowLine ? this.options.scaleLineWidth : 0, lineColor:this.options.scaleLineColor, angleLineColor:this.options.angleLineColor, angleLineWidth:this.options.angleShowLineOut ? this.options.angleLineWidth : 0, pointLabelFontColor:this.options.pointLabelFontColor, pointLabelFontSize:this.options.pointLabelFontSize, pointLabelFontFamily:this.options.pointLabelFontFamily, pointLabelFontStyle:this.options.pointLabelFontStyle, height:this.chart.height, width:this.chart.width, 
    xCenter:this.chart.width / 2, yCenter:this.chart.height / 2, ctx:this.chart.ctx, templateString:this.options.scaleLabel, labels:c.labels, valuesCount:c.datasets[0].data.length});
    this.scale.setScaleSize();
    this.updateScaleRange(c.datasets);
    this.scale.buildYLabels();
  }, updateScaleRange:function(c) {
    var b = function() {
      var b = [];
      d.each(c, function(c) {
        c.data ? b = b.concat(c.data) : d.each(c.points, function(c) {
          b.push(c.value);
        });
      });
      return b;
    }();
    b = this.options.scaleOverride ? {steps:this.options.scaleSteps, stepValue:this.options.scaleStepWidth, min:this.options.scaleStartValue, max:this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth} : d.calculateScaleRange(b, d.min([this.chart.width, this.chart.height]) / 2, this.options.scaleFontSize, this.options.scaleBeginAtZero, this.options.scaleIntegersOnly);
    d.extend(this.scale, b);
  }, addData:function(c, b) {
    this.scale.valuesCount++;
    d.each(c, function(c, d) {
      var f = this.scale.getPointPosition(this.scale.valuesCount, this.scale.calculateCenterOffset(c));
      this.datasets[d].points.push(new this.PointClass({value:c, label:b, datasetLabel:this.datasets[d].label, x:f.x, y:f.y, strokeColor:this.datasets[d].pointStrokeColor, fillColor:this.datasets[d].pointColor}));
    }, this);
    this.scale.labels.push(b);
    this.reflow();
    this.update();
  }, removeData:function() {
    this.scale.valuesCount--;
    this.scale.labels.shift();
    d.each(this.datasets, function(c) {
      c.points.shift();
    }, this);
    this.reflow();
    this.update();
  }, update:function() {
    this.eachPoints(function(c) {
      c.save();
    });
    this.reflow();
    this.render();
  }, reflow:function() {
    d.extend(this.scale, {width:this.chart.width, height:this.chart.height, size:d.min([this.chart.width, this.chart.height]), xCenter:this.chart.width / 2, yCenter:this.chart.height / 2});
    this.updateScaleRange(this.datasets);
    this.scale.setScaleSize();
    this.scale.buildYLabels();
  }, draw:function(c) {
    var b = c || 1, f = this.chart.ctx;
    this.clear();
    this.scale.draw();
    d.each(this.datasets, function(c) {
      d.each(c.points, function(c, d) {
        c.hasValue() && c.transition(this.scale.getPointPosition(d, this.scale.calculateCenterOffset(c.value)), b);
      }, this);
      f.lineWidth = this.options.datasetStrokeWidth;
      f.strokeStyle = c.strokeColor;
      f.beginPath();
      d.each(c.points, function(b, c) {
        0 === c ? f.moveTo(b.x, b.y) : f.lineTo(b.x, b.y);
      }, this);
      f.closePath();
      f.stroke();
      f.fillStyle = c.fillColor;
      this.options.datasetFill && f.fill();
      d.each(c.points, function(b) {
        b.hasValue() && b.draw();
      });
    }, this);
  }});
}).call(this);
